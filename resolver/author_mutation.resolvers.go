package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"
	"go-template/daos"
	"go-template/gqlmodels"
	"go-template/models"
	"go-template/pkg/utl/cnvrttogql"
	"go-template/pkg/utl/resultwrapper"
	"go-template/pkg/utl/throttle"
	"time"

	null "github.com/volatiletech/null/v8"
)

// CreateAuthor is the resolver for the createAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, input gqlmodels.AuthorCreateInput) (*gqlmodels.Author, error) {
	err := throttle.Check(ctx, 5, 10*time.Second)
	if err != nil {
		return nil, err
	}

	author := models.Author{
		Email:     null.StringFrom(input.Email),
		FirstName: null.StringFrom(input.FirstName),
		LastName:  null.StringFrom(input.LastName),
	}
	newAuthor, err := daos.CreateAuthor(author, ctx)
	if err != nil {
		return nil, resultwrapper.ResolverSQLError(err, "Author information")
	}
	graphAuthor := cnvrttogql.AuthorToGraphQlAuthor(&newAuthor)

	return graphAuthor, err
}

// UpdateAuthor is the resolver for the updateAuthor field.func (r *mutationResolver) UpdateAuthor(ctx context.Context, input gqlmodels.AuthorUpdateInput) (*gqlmodels.Author, error) {
func (r *mutationResolver) UpdateAuthor(ctx context.Context, input gqlmodels.AuthorUpdateInput) (*gqlmodels.Author, error) {
	var u *models.Author
	var err error
	u, err = daos.FindAuthorWithId(input.ID, ctx)
	if err != nil {
		return nil, resultwrapper.ResolverSQLError(err, "data")
	}
	if input.FirstName != nil {
		u.FirstName = null.StringFromPtr(input.FirstName)
	}
	if input.LastName != nil {
		u.LastName = null.StringFromPtr(input.LastName)
	}
	if input.Email != nil {
		u.Email = null.StringFromPtr(input.Email)
	}
	// update the author in the database
	_, err = daos.UpdateAuthor(*u, ctx)
	if err != nil {
		return nil, resultwrapper.ResolverSQLError(err, "new information")
	}
	// convert the updated author to a graphql author
	graphAuthor := cnvrttogql.AuthorToGraphQlAuthor(&*u)
	return graphAuthor, nil
}

// DeleteAuthor is the resolver for the deleteAuthor field.
func (r *mutationResolver) DeleteAuthor(ctx context.Context, input gqlmodels.AuthorDeleteInput) (*gqlmodels.AuthorDeletePayload, error) {
	u, err := daos.FindAuthorWithId(input.ID, ctx)
	if err != nil {
		return nil, resultwrapper.ResolverSQLError(err, "data")
	}
	_, err = daos.DeleteAuthor(*u, ctx)
	if err != nil {
		return nil, resultwrapper.ResolverSQLError(err, "author")
	}
	return &gqlmodels.AuthorDeletePayload{ID: fmt.Sprint(input.ID)}, nil
}
